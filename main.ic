/*!
 * \file   main.ic
 * \author Joseph Warner (warner.512@osu.edu)
 * \date   Spring, 2013
 * \brief  Controls the robot in the competition
 */

/**
 * All constants used in the operation of the robot
 */
/**
 * Hardware Constants
 *   All ports in numerical order within 
 */
/* Analog */
/** Analog port of the CDS Cell */
#define CDS_CELL 6

/* Digital */
/** Digital port of the Microswitch located on the front right */
#define MICROSWITCH_RIGHT_FRONT 14
/** Digital port of the Microswitch located on the front left */
#define MICROSWITCH_LEFT_FRONT  15

/* DC Motors */
/** Motor port of the left motor */
#define MOTOR_LEFT  0
/** Motor port of the right motor */
#define MOTOR_RIGHT 2

/**
 * Motor constants
 */
/** The maximum speed that the motors will be run at */
#define MOTOR_TOP_SPEED -75
/** The minimum speed that the motors will be run at */
#define MOTOR_STOPPED    0

/**
 * Sensor Constants
 */
/* CDS Cell Readings */
/** The defined point between a light on the ground and no light */
#define CDS_LIGHT_START 35
/** The reading from the CDS defined to be an indicator of a red light */
#define CDS_LIGHT_RED   0
/** The reading from the CDS defined to be an indicator a blue light */
#define CDS_LIGHT_BLUE  0

/**
 * Action Constants
 */
/* Quasi-Actions */
/** Start of the run */
#define ACTION_START           0
/** Stops all physical activity on the robot */
#define ACTION_STOP            1
/** One second wait before any additional processes */
#define ACTION_WAIT_ONE_SECOND 2
/** No action */
#define ACTION_NULL            3

/* Movement Directions */
/** Move forward */
#define ACTION_FORWARD   10
/** Move backwards */
#define ACTION_BACKWARDS 11
/** Move right */
#define ACTION_RIGHT     12
/** Move left */
#define ACTION_LEFT      13

/**
 * Event Constants
 */
/* Microswitch Events */
/** Right front microswitch pressed */
#define EVENT_MS_RF_PRESS 0
/** Left front microswitch pressed */
#define EVENT_MS_LF_PRESS 1
/** Both front microswitches pressed */
#define EVENT_MS_BF_PRESS 2
/** One front microswitch pressed */
#define EVENT_MS_EF_PRESS 3

/* Light Sensor Events */
/** Light recognized by CDS cell */
#define EVENT_CDS_LIGHT    10
/** No light recognized by CDS cell */
#define EVENT_CDS_NO_LIGHT 11
/** Blue light recognized by CDS cell */
#define EVENT_CDS_BLUE     12
/** Red light recognized by CDS cell */
#define EVENT_CDS_RED      13

/* Button Events */
/** Stop button pressed */
#define EVENT_BUTTON_STOP_PRESSED  20
/** Start button pressed */
#define EVENT_BUTTON_START_PRESSED 21

/**
 * Comparison Constants
 *   These are used by compare_values
 */
/** Greater than */
#define COMPARISON_GREATER 2
/** Equal to */
#define COMPARISON_EQUAL   1
/** Less than */
#define COMPARISON_LESSER  0

/**
 * Defines global variables:
 *   int   action_chain[]
 *           The chain of actions that will be taken
 *   int   event_chain[]
 *           The chain of actions that will trigger the corresponding action_chain item
 *   int   chain_index
 *           The current index in event_chain
 *   int   chain_max_index
 *           The index at which execution stops
 *   int   motor_speed_left
 *           The speed of the left motor
 *   int   motor_speed_right
 *           The speed of the right motor
 */
int  action_chain[]    = {ACTION_START,               ACTION_FORWARD,  ACTION_NULL,       ACTION_STOP};//,       ACTION_STOP};
int  event_chain[]     = {EVENT_BUTTON_START_PRESSED, EVENT_CDS_LIGHT, EVENT_MS_EF_PRESS, EVENT_MS_BF_PRESS};//, EVENT_BUTTON_STOP_PRESSED};
int  chain_index       = 0;
int  chain_max_index   = _array_size(action_chain);
int  motor_speed_left  = MOTOR_STOPPED;
int  motor_speed_right = MOTOR_STOPPED;
long last_action       = mseconds();

/**
 * Compares the values value1 and value2 based on the check.
 *
 * Parameters
 *   int   value1
 *           The first value being compared
 *   int   value2
 *           The second value being compared
 *   int   check
 *           Corresponds to the comparison constants
 *
 * Return
 *   int   1 for true, 0 for false, -1 for invalid check 
 */
int compare_values(int value1, int value2, int check) {
    if (check == COMPARISON_LESSER) {
        if (value1 < value2) {
            return 1;
        } else {
            return 0;
        }
    }
    
    if (check == COMPARISON_EQUAL) {
        if (value1 == value2) {
            return 1;
        } else {
            return 0;
        }
    }
    
    if (check == COMPARISON_GREATER) {
        if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    }
    
    // Invalid check
    return -1;
}

/**
 * Checks the CDS reading and compares it to be <, ==, or > to a value
 *
 * Parameters
 *   int   CDS_cell
 *           The analog port number of the CDS cell being checked
 *   int   value
 *           The value being compared to the CDS cell analog reading
 *   int   check
 *           Corresponds to the comparison constants
 *
 * Return
 *   int   see compare_values
 */
int event_check_CDS(int port, int value, int check) {
    return compare_values(analog(port), value, check);
}

/**
 * Check to see if the specified event has occurred
 *
 * Parameters
 *   int   event
 *           Corresponds to Event constants
 *
 * Return
 *   int   1 for event has occurred, 0 for event has not occurred
 */
int event_check(int event) {
    switch (event) {
        /* Microswitch Events */
        case EVENT_MS_RF_PRESS:
          return digital(MICROSWITCH_RIGHT_FRONT);
        break;
        case EVENT_MS_LF_PRESS:
          return digital(MICROSWITCH_LEFT_FRONT);
        break;
        case EVENT_MS_BF_PRESS:
          return digital(MICROSWITCH_LEFT_FRONT) && digital(MICROSWITCH_RIGHT_FRONT);
        break;
        case EVENT_MS_EF_PRESS:
          if (digital(MICROSWITCH_LEFT_FRONT) || digital(MICROSWITCH_RIGHT_FRONT)) {
            if(digital(MICROSWITCH_LEFT_FRONT) && digital(MICROSWITCH_RIGHT_FRONT)) {
                motor_speed_left  = MOTOR_STOPPED;
                motor_speed_right = MOTOR_STOPPED;
            } else if(digital(MICROSWITCH_LEFT_FRONT)) {
                motor_speed_right  = MOTOR_STOPPED;
            } else {
                motor_speed_left = MOTOR_STOPPED;
            }
            return 1;
        } else {
            return 0;
        }
        /* CDS Cell Events */
        case EVENT_CDS_LIGHT:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_START, COMPARISON_LESSER);
        break;
        case EVENT_CDS_NO_LIGHT:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_START, COMPARISON_GREATER);
        break;
        case EVENT_CDS_BLUE:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_BLUE, COMPARISON_GREATER);
        break;
        case EVENT_CDS_RED:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_RED, COMPARISON_GREATER);
        break;
        /* Button Events */
        case EVENT_BUTTON_STOP_PRESSED:
          return stop_button();
        break;
        case EVENT_BUTTON_START_PRESSED:
          return start_button();
        break;
    }
    
    return 0;
}

/**
 * Checks to see if the current chain_index in the event_chain should occur
 */
int step() {
    if (event_check(event_chain[chain_index]) == 1) {
        return execute_step();
    }
    
    return 1;
}

/**
 * Updates the motors to the latest speeds
 */
int update_motors() {
    motor(MOTOR_LEFT, motor_speed_left);
    motor(MOTOR_RIGHT, motor_speed_right);
    return 0;
}

/**
 * Executes the current chain_index in action_chain then increments chain_index by 1
 */
int execute_step() {
    int action = action_chain[chain_index];
    switch(action) {
        /* Quasi Actions */
        case ACTION_START:
          printf("Ready to start run\n");
        break;
        case ACTION_STOP:
          motor_speed_left  = MOTOR_STOPPED;
        motor_speed_right = MOTOR_STOPPED;
        update_motors();
        printf("Run Complete\n");
        break;
        case ACTION_NULL:
          update_motors();
        break;
        /* Motor Actions */
        case ACTION_FORWARD:
          motor_speed_left  = MOTOR_TOP_SPEED;
        motor_speed_right = MOTOR_TOP_SPEED;
        update_motors();
        printf("Forward\n");
        break;
        case ACTION_BACKWARDS:
          motor_speed_left  = -1 * MOTOR_TOP_SPEED;
        motor_speed_right = -1 * MOTOR_TOP_SPEED;
        update_motors();
        printf("Backwards\n");
        break;
        case ACTION_RIGHT:
          motor_speed_left  = -1 * MOTOR_TOP_SPEED;
        motor_speed_right = MOTOR_TOP_SPEED;
        update_motors();
        printf("Right\n");
        break;
        case ACTION_LEFT:
          motor_speed_left  = MOTOR_TOP_SPEED;
        motor_speed_right = -1 * MOTOR_TOP_SPEED;
        update_motors();
        printf("Left\n");
        break;
    }
    
    chain_index++;
    last_action = mseconds();
    beep();
    return 0;
}

/**
 * Launch the robot and handle startup
 */
int main() {
    // Keep the robot stopped
    update_motors();
    
    // Tell the user to start the run
    printf("Press Start to start run\n");
    
    /* Execute the steps in order until tall steps have been taken */
    while (chain_index < chain_max_index) {
        step();
    }
    
    chain_index = 0;
    action_chain[chain_index] = ACTION_BACKWARDS;
    execute_step();
    sleep(0.75);
    
    chain_index = 0;
    action_chain[chain_index] = ACTION_RIGHT;
    execute_step();
    sleep(0.5);
    
    // Hit wall on upper level
    chain_index = 0;
    action_chain[chain_index] = ACTION_FORWARD;
    action_chain[chain_index + 1] = ACTION_NULL;
    event_chain[chain_index + 1] = EVENT_MS_EF_PRESS;
    action_chain[chain_index + 2] = ACTION_STOP;
    event_chain[chain_index + 2] = EVENT_MS_BF_PRESS;
    execute_step();
    while(chain_index < 3) {
        step();
    }
    
    chain_index = 0;
    action_chain[chain_index] = ACTION_BACKWARDS;
    execute_step();
    sleep(0.75);
    
    chain_index = 0;
    action_chain[chain_index] = ACTION_LEFT;
    execute_step();
    sleep(0.5);
    
    chain_index = 0;
    action_chain[chain_index] = ACTION_FORWARD;
    action_chain[chain_index + 1] = ACTION_NULL;
    event_chain[chain_index + 1] = EVENT_MS_EF_PRESS;
    action_chain[chain_index + 2] = ACTION_STOP;
    event_chain[chain_index + 2] = EVENT_MS_BF_PRESS;
    execute_step();
    while(chain_index < 3) {
        step();
    }
    
    /* Shutdown all motors */
    motor_speed_left  = MOTOR_STOPPED;
    motor_speed_right = MOTOR_STOPPED;
    update_motors();
    
    return 0;
}
