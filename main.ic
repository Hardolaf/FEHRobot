/*!
 * \file   main.ic
 * \author Joseph Warner (warner.512@osu.edu)
 * \date   Spring, 2013
 * \brief  Controls the robot in the competition
 */

/*!
 * \defgroup hardware_constants Hardware Constants
 * These constants correspond to the hardware ports that each device is
 * connected to. Some of the ports are analog, some are digital.
 @{*/
/*! Analog port of the center Optosensor */
#define OPTOSENSOR_LINE_FOLLOWING_CENTER 4
/*@}*/

/*!
 * \defgroup sensor_constants Sensor Constants
 * These constants all correspond to experimentally determined values used to
 * calibrate the various sensors on the robot.
 @{*/
/*! The reading from the middle line following optosensor defined as seeing a line */
#define OPTOSENSOR_LINE_FOLLOWING_CENTER_LINE 30  
/*@}*/

/*!
 * \defgroup action_constants Action Constants
 * These constants define all of the simplified actions that the robot may take
 * during operation. More complex actions can be created by combining these
 * actions with other actions.
 @{*/
/*! Start of the run */
#define ACTION_START           0
/*! Stops all physical activity on the robot */
#define ACTION_STOP            1
/*! One second wait before any additional processes */
#define ACTION_WAIT_ONE_SECOND 2
/*! No action */
#define ACTION_NULL            3

/*! Move forward */
#define ACTION_FORWARD   10
/*! Move backwards */
#define ACTION_BACKWARDS 11
/*! Move right */
#define ACTION_RIGHT     12
/*! Move left */
#define ACTION_LEFT      13
/*! Follow line forwards */
#define ACTION_MOVE_FOLLOW_LINE_FORWARD 14
/*! Follow line backwards */
#define ACTION_MOVE_FOLLOW_LINE_BACKWARDS 15

/*! Course action press button */
#define ACTION_COURSE_PRESS_BUTTON 20
/*! Course action flip generator switch */
#define ACTION_COURSE_FLIP_SWITCH 21
/*@}*/

/*!
 * \defgroup event_constants Event Constants
 * These constants define the various events that can be observed during
 * robot operation.
 @{*/
/*! Right front microswitch pressed */
#define EVENT_MS_RF_PRESS 0
/*! Left front microswitch pressed */
#define EVENT_MS_LF_PRESS 1
/*! Both front microswitches pressed */
#define EVENT_MS_BF_PRESS 2
/*! One front microswitch pressed */
#define EVENT_MS_EF_PRESS 3
/*! Right back microswitch pressed */
#define EVENT_MS_RB_PRESS 4
/*! Left back microswitch pressed */
#define EVENT_MS_LB_PRESS 5
/*! Both back microswitches pressed */
#define EVENT_MS_BB_PRESS 6
/*! One back microswitch pressed */
#define EVENT_MS_EB_PRESS 7

/*! Light recognized by CDS cell */
#define EVENT_CDS_LIGHT    10
/*! No light recognized by CDS cell */
#define EVENT_CDS_NO_LIGHT 11
/*! Blue light recognized by CDS cell */
#define EVENT_CDS_BLUE     12
/*! Red light recognized by CDS cell */
#define EVENT_CDS_RED      13

/*! Stop button pressed */
#define EVENT_BUTTON_STOP_PRESSED  20
/*! Start button pressed */
#define EVENT_BUTTON_START_PRESSED 21

/*! Course satellite button pressed */
#define EVENT_COURSE_SATELLITE_BUTTON_PRESSED 30
/*! Course generator switch flipped */
#define EVENT_COURSE_GENERATOR_FLIP_SWITCHED  31

/*! Optosensor sees line */
#define EVENT_OPTOSENSOR_SEE_LINE 40
/*! Optosensor lose line */
#define EVENT_OPTOSENSOR_LOSE_LINE 41

/*! Event Null */
#define EVENT_NULL 50
/*@}*/

/*!
 * \defgroup comparison_constants Comparison Constants
 * These are used by compare_values
 @{*/
/*! Greater than */
#define COMPARISON_GREATER 2
/*! Equal to */
#define COMPARISON_EQUAL   1
/*! Less than */
#define COMPARISON_LESSER  0
/*@}*/

/*!
 * \defgroup global_variables Global Variables
 * All global variables used in the execution of the robot.
 @{*/
/*! The chain of actions that will be take */
int  action_chain[]    = {ACTION_BACKWARDS, ACTION_FORWARD,     ACTION_LEFT,
      ACTION_COURSE_PRESS_BUTTON, ACTION_MOVE_FOLLOW_LINE_BACKWARDS,  ACTION_RIGHT,
      ACTION_FORWARD, ACTION_BACKWARDS,  ACTION_LEFT,
      ACTION_COURSE_FLIP_SWITCH,  ACTION_FORWARD, ACTION_RIGHT,
      ACTION_FORWARD, ACTION_BACKWARDS,   ACTION_LEFT,    ACTION_FORWARD,
      ACTION_STOP};
/*! The chain of actions that will trigger the corresponding action_chain item */
int  event_chain[]     = {EVENT_CDS_LIGHT,  EVENT_MS_BB_PRESS,  EVENT_OPTOSENSOR_SEE_LINE,
      EVENT_NULL,                 EVENT_NULL,                         EVENT_NULL,
      EVENT_NULL,     EVENT_MS_EF_PRESS, EVENT_OPTOSENSOR_SEE_LINE,
      EVENT_NULL,                 EVENT_NULL,     EVENT_OPTOSENSOR_SEE_LINE, 
      EVENT_NULL,     EVENT_MS_EF_PRESS,  EVENT_NULL,     EVENT_NULL,
      EVENT_BUTTON_STOP_PRESSED};
/*! The current index in event_chain */
int  chain_index       = 0;
/*! The index at which execution stops */
int  chain_max_index   = _array_size(action_chain);
/*! The speed of the left motor */
int  motor_speed_left  = MOTOR_SPEED_STOPPED;
/*! The speed of the right motor */
int  motor_speed_right = MOTOR_SPEED_STOPPED;
/*! The time of the last actions in milliseconds since the robot was turn on. */
long last_action       = mseconds();
/*@}*/

/*!
 * \defgroup functions Functions
 * The functions that make the robot operate
 @{*/
/*!
 * Compares the values value1 and value2 based on the check.
 *
 * \param[in] value1 The first value being compared
 * \param[in] value2 The second value being compared
 * \param[in] check Corresponds to a comparison constant
 * \return 1 for true, 0 for false, -1 for invalid check 
 */
int compare_values(int value1, int value2, int check) {
    if (check == COMPARISON_LESSER) {
        if (value1 < value2) {
            return 1;
        } else {
            return 0;
        }
    }
    
    if (check == COMPARISON_EQUAL) {
        if (value1 == value2) {
            return 1;
        } else {
            return 0;
        }
    }
    
    if (check == COMPARISON_GREATER) {
        if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    }
    
    // Invalid check
    return -1;
}

/*!
 * Checks the CDS reading and compares it to be <, ==, or > to a value
 *
 * \param[in] port The analog port number of the CDS cell being checked
 * \param[in] value The value being compared to the CDS cell analog reading
 * \param[in] check The type of check being requested corresponding to the
 * comparison constants
 * \see compare_values()
 * \return Output from compare_values
 */
int event_check_CDS(int port, int value, int check) {
    return compare_values(analog(port), value, check);
}

/*!
 * Check to see if the specified event has occurred
 *
 * \param[in] event Corresponds to an event constant
 * \see event_check_CDS()
 * \return 1 for event has occurred, 0 for event has not occurred
 */
int event_check(int event) {
    switch (event) {
        /* Microswitch Events */
        case EVENT_MS_RF_PRESS:
          return digital(MICROSWITCH_RIGHT_FRONT);
        break;
        case EVENT_MS_LF_PRESS:
          return digital(MICROSWITCH_LEFT_FRONT);
        break;
        case EVENT_MS_BF_PRESS:
          return digital(MICROSWITCH_LEFT_FRONT) || digital(MICROSWITCH_RIGHT_FRONT);
        return digital(MICROSWITCH_LEFT_FRONT) && digital(MICROSWITCH_RIGHT_FRONT);
        break;
        case EVENT_MS_EF_PRESS:
          return digital(MICROSWITCH_LEFT_FRONT) || digital(MICROSWITCH_RIGHT_FRONT);
        if (digital(MICROSWITCH_LEFT_FRONT) || digital(MICROSWITCH_RIGHT_FRONT)) {
            if(digital(MICROSWITCH_LEFT_FRONT) && digital(MICROSWITCH_RIGHT_FRONT)) {
                motor_speed_left  = MOTOR_SPEED_STOPPED;
                motor_speed_right = MOTOR_SPEED_STOPPED;
            } else if(digital(MICROSWITCH_LEFT_FRONT)) {
                motor_speed_right  = MOTOR_SPEED_STOPPED;
            } else {
                motor_speed_left = MOTOR_SPEED_STOPPED;
            }
            return 1;
        } else {
            return 0;
        }
        case EVENT_MS_RB_PRESS:
          return digital(MICROSWITCH_RIGHT_BACK);
        break;
        case EVENT_MS_LB_PRESS:
          return digital(MICROSWITCH_LEFT_BACK);
        break;
        case EVENT_MS_BB_PRESS:
          return digital(MICROSWITCH_LEFT_BACK) && digital(MICROSWITCH_RIGHT_BACK);
        break;
        case EVENT_MS_EB_PRESS:
          if (digital(MICROSWITCH_LEFT_BACK) || digital(MICROSWITCH_RIGHT_BACK)) {
            if(digital(MICROSWITCH_LEFT_BACK) && digital(MICROSWITCH_RIGHT_BACK)) {
                motor_speed_left  = MOTOR_SPEED_STOPPED;
                motor_speed_right = MOTOR_SPEED_STOPPED;
            } else if(digital(MICROSWITCH_LEFT_BACK)) {
                motor_speed_right  = MOTOR_SPEED_STOPPED;
            } else {
                motor_speed_left = MOTOR_SPEED_STOPPED;
            }
            return 1;
        } else {
            return 0;
        }
        /* CDS Cell Events */
        case EVENT_CDS_LIGHT:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_START, COMPARISON_LESSER);
        break;
        case EVENT_CDS_NO_LIGHT:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_START, COMPARISON_GREATER);
        break;
        case EVENT_CDS_BLUE:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_BLUE, COMPARISON_GREATER);
        break;
        case EVENT_CDS_RED:
          return event_check_CDS(CDS_CELL, CDS_LIGHT_RED, COMPARISON_GREATER);
        break;
        /* Button Events */
        case EVENT_BUTTON_STOP_PRESSED:
          return stop_button();
        break;
        case EVENT_BUTTON_START_PRESSED:
          return start_button();
        break;
        /* Optosensor Events */
        case EVENT_OPTOSENSOR_SEE_LINE:
          return analog(OPTOSENSOR_LINE_FOLLOWING_CENTER) < OPTOSENSOR_LINE_FOLLOWING_CENTER_LINE;
        break;
        case EVENT_OPTOSENSOR_LOSE_LINE:
          return analog(OPTOSENSOR_LINE_FOLLOWING_CENTER) > OPTOSENSOR_LINE_FOLLOWING_CENTER_LINE;
        break;
        /* Special Events */
        case EVENT_NULL:
          return 1;
    }
    
    return 0;
}

/*!
 * Checks to see if the current chain_index in the event_chain should occur
 *
 * \see event_check()
 * \see event_chain
 * \see chain_index
 * \see execute_step()
 * \return execute_step()'s status code or 1
 */
int step() {
    if (event_check(event_chain[chain_index]) == 1) {
        return execute_step();
    }
    
    return 1;
}

/*!
 * Updates the motors to the latest speeds
 *
 * \see motor_speed_left
 * \see motor_speed_right
 * \return 0 on success
 */
int update_motors() {
    motor(MOTOR_LEFT, motor_speed_left);
    motor(MOTOR_RIGHT, motor_speed_right);
    return 0;
}

/*!
 * Executes the current chain_index in action_chain then increments chain_index
 * by 1
 *
 * \see action_chain
 * \see chain_index
 * \return 0 on success
 */
int execute_step() {
    int action = action_chain[chain_index];
    switch(action) {
        /* Quasi Actions */
        case ACTION_START:
          printf("Ready to start run\n");
        break;
        case ACTION_STOP:
          motor_speed_left  = MOTOR_SPEED_STOPPED;
        motor_speed_right = MOTOR_SPEED_STOPPED;
        update_motors();
        printf("Run Complete\n");
        break;
        case ACTION_NULL:
          update_motors();
        break;
        /* Motor Actions */
        case ACTION_FORWARD:
          motor_speed_left  = MOTOR_SPEED_MAX;
        motor_speed_right = MOTOR_SPEED_MAX;
        update_motors();
        printf("Forward\n");
        break;
        case ACTION_BACKWARDS:
          motor_speed_left  = -1 * MOTOR_SPEED_MAX;
        motor_speed_right = -1 * MOTOR_SPEED_MAX;
        update_motors();
        printf("Backwards\n");
        break;
        case ACTION_RIGHT:
          motor_speed_left  = -1 * MOTOR_SPEED_MAX;
        motor_speed_right = MOTOR_SPEED_MAX;
        update_motors();
        printf("Right\n");
        break;
        case ACTION_LEFT:
          motor_speed_left  = MOTOR_SPEED_MAX;
        motor_speed_right = -1 * MOTOR_SPEED_MAX;
        update_motors();
        printf("Left\n");
        break;
        case ACTION_MOVE_FOLLOW_LINE_FORWARD:
          execute_follow_line(1);
        break;
        case ACTION_MOVE_FOLLOW_LINE_BACKWARDS:
          execute_follow_line(-1);
        break;
        /* Course Actions */
        case ACTION_COURSE_PRESS_BUTTON:
          execute_press_button();
        break;
        case ACTION_COURSE_FLIP_SWITCH:
          execute_flip_switch();
        break;
    }
    
    chain_index++;
    last_action = mseconds();
    beep();
    return 0;
}

/*!
 * Executes the follow line process
 *
 * \todo Update to use all three sensors
 * \author Joseph Warner
 * \author Miranda McGrothers
 * \param[in] direction 1 for forward, -1 for backwards
 * \return 0 on success, 1 on line lost
 */
int execute_follow_line(int direction) {
    if (analog(OPTOSENSOR_LINE_FOLLOWING_CENTER) > OPTOSENSOR_LINE_FOLLOWING_CENTER_LINE) {
        motor_speed_left = -1 * direction * -10 ;
        motor_speed_right = direction * -25;
    } else {
        motor_speed_left = direction * MOTOR_SPEED_LINE_FOLLOWING * 2;
        motor_speed_right = -1 * direction * MOTOR_SPEED_LINE_FOLLOWING;
    }
    
    update_motors();
    return 0;
}

/*!
 * Executes the press button process
 * Assumes that the robot has already reached the line
 *
 * \return 0 on success
 */
int execute_press_button() {
    // Move forward to press the button
    printf("Pressing button\n");
    last_action = mseconds();
    while (last_action + (long)2000 > mseconds()) {
        if (execute_follow_line(1) == 1) {
            break;
        }
    }
    
    // Press button
    motor_speed_right = MOTOR_SPEED_LINE_FOLLOWING;
    motor_speed_left  = MOTOR_SPEED_LINE_FOLLOWING;
    update_motors();
    sleep(0.1);
}

/*!
 * Executes the flip switch process
 *
 * \todo Allow flipping switch in either direction
 * \return 0 on success
 */
int execute_flip_switch() {
    // Back up into the switch
    printf("Flipping switch\n");
    last_action = mseconds();
    while (last_action + (long)250 > mseconds()) {
        if (execute_follow_line(1) == 1) {
            break;
        }
    }
    
    // Stop the vehicle
    motor_speed_right = MOTOR_SPEED_STOPPED;
    motor_speed_left = MOTOR_SPEED_STOPPED;
    update_motors();
}

/*!
 * Executes the ascend steps process
 *
 * \return 0 on success
 */
int execute_ascend_steps() {
    
}

/*!
 * Executes the ascend ramp process
 *
 * \return 0 on success
 */
int execute_ascend_ramp() {
    
}

/*!
 * Handles the logic in switching between the various tasks that the must
 * undergo during the competition. This function also contains the exact order
 * of the various tasks that will be completed.
 *
 * \return 0 on success
 */
int main() {
    // Keep the robot stopped
    update_motors();
    
    // Tell the user to start the run
    printf("Press Start to start run\n");
    while(!start_button());
    sleep(0.25);
    printf("1\n");
    
    // wait for light to start
    while(event_check_CDS(CDS_CELL, CDS_LIGHT_START, COMPARISON_LESSER) == 0);
    printf("2\n");
    
    // Head backwards
    motor_speed_left = -1 * MOTOR_SPEED_MAX;
    motor_speed_right = -1 * 3 *MOTOR_SPEED_MAX;
    update_motors();
    sleep(5.0);
    
    motor_speed_right = MOTOR_SPEED_MAX;
    motor_speed_left = MOTOR_SPEED_MAX;
    update_motors();
    sleep(5.0);
    ao();
    return 0;
    
    while (!(digital(MICROSWITCH_LEFT_BACK) && digital(MICROSWITCH_RIGHT_BACK))) {
        if (digital(MICROSWITCH_LEFT_BACK)) {
            motor_speed_right = -1 * MOTOR_SPEED_MAX;
            motor_speed_left = MOTOR_SPEED_STOPPED;
        } else if (digital(MICROSWITCH_RIGHT_BACK)) {
            motor_speed_right = MOTOR_SPEED_STOPPED;
            motor_speed_left = -1 * MOTOR_SPEED_MAX;
        } else {
            motor_speed_left = -1 * MOTOR_SPEED_MAX;
            motor_speed_right = -1 * MOTOR_SPEED_MAX;
        }
        update_motors();
    }
    printf("3\n");
    
    // Stop against the wall
    motor_speed_right = MOTOR_SPEED_STOPPED;
    motor_speed_left = MOTOR_SPEED_STOPPED;
    update_motors();
    sleep (0.25);
    printf("4\n");
    
    // Forward a bit
    motor_speed_left = MOTOR_SPEED_MAX;
    motor_speed_right = MOTOR_SPEED_MAX;
    update_motors();
    sleep(0.1);
    printf("5\n");
    
    // Turn right 45 degrees
    motor_speed_left = 3 * MOTOR_SPEED_MAX;
    motor_speed_right = (-3) * MOTOR_SPEED_MAX;
    update_motors();
    sleep(0.35);
    printf("6\n");
    
    
    // Head forwards until we see the line
    motor_speed_right = MOTOR_SPEED_MAX;
    motor_speed_left = MOTOR_SPEED_MAX;
    update_motors();
    sleep (0.1); // Try to get past the start area before starting to read
    printf("7\n");
    
    while(analog(OPTOSENSOR_LINE_FOLLOWING_CENTER) > OPTOSENSOR_LINE_FOLLOWING_CENTER_LINE) {
        printf("%d\n", analog(OPTOSENSOR_LINE_FOLLOWING_CENTER));
    }
    printf("8\n");
    
    // Follow line
    while (!digital(MICROSWITCH_RIGHT_FRONT)) {
        execute_follow_line(1);
    }
    printf("9\n");
    
    // Back up
    motor_speed_left = -1 * MOTOR_SPEED_MAX;
    motor_speed_right = -1 * MOTOR_SPEED_MAX;
    update_motors();
    printf("10\n");
    
    while (!(digital(MICROSWITCH_LEFT_BACK) && digital(MICROSWITCH_RIGHT_BACK))) {
        if (digital(MICROSWITCH_LEFT_BACK)) {
            motor_speed_right = -1 * MOTOR_SPEED_MAX;
            motor_speed_left = MOTOR_SPEED_STOPPED;
        } else if (digital(MICROSWITCH_RIGHT_BACK)) {
            motor_speed_right = MOTOR_SPEED_STOPPED;
            motor_speed_left = -1 * MOTOR_SPEED_MAX;
        } else {
            motor_speed_left = -1 * MOTOR_SPEED_MAX;
            motor_speed_right = -1 * MOTOR_SPEED_MAX;
        }
        update_motors();
    }
    printf("11\n");
    ao();
    
    /* Execute the steps in order until tall steps have been taken */
    /*while (chain_index < chain_max_index) {
        if(event_check(event_chain[chain_index])) {
            
        switch(chain_index) {
            case 3:
              sleep(0.25);
            chain_index++;
            break;
            case 5:
              sleep(0.25);
            chain_index++;
            break;
            case 6:
              sleep(0.25);
            chain_index++;
            break;
            case 9:
              sleep(0.25);
            chain_index++;
            break;
            case 12:
              sleep(0.25);
            chain_index++;
            break;
            case 14:
              sleep(0.25);
            chain_index++;
            break;
            case 15:
              sleep(0.25);
            chain_index++;
            break;
            default:
              step();
            break;
            }
        }
    }*/
    
    printf("Run completed\n");
    
    return 0;
}
/*@}*/
